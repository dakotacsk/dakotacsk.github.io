{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PathFinders View in your space \ud83d\ude80 Discover the Future of Algorithmic Exploration \ud83d\ude80 PathFinder isn't just a game \u2014 it's an adventure into the world of pathfinding algorithm visualizations . Whether you're a gamer, a curious mind, or an educator, PathFinder brings the complex world of Q-learning and Dijkstra's to life in a way that's engaging, educational, and just plain fun. \ud83d\udcf8 Game Snapshots Take a sneak peek into the world of PathFinder! \ud83c\udfae Features Arcade-Style Gameplay : Immerse yourself in a hands-on learning experience with sleek visuals and intuitive controls. Interactive Algorithms : Visualize and interact with complex concepts like Dijkstra\u2019s Algorithm and Q-Learning through real-time simulations. Challenge Your Intellect : Test your problem-solving skills while learning about decision-making and optimization techniques. \ud83d\udee0\ufe0f Build Your Own Inspired to create something similar? We\u2019ve got you covered. Access our open-source resources and guides to make your own version of PathFinder: \ud83d\udcbe Download Game \ud83c\udf89 Join the Journey Stay updated with our latest features, contribute ideas, or just get to know the amazing team behind this. \ud83e\udd1d Meet the Team \ud83d\udc49 Follow us on GitHub","title":"Home"},{"location":"#welcome-to-pathfinders","text":"View in your space \ud83d\ude80 Discover the Future of Algorithmic Exploration \ud83d\ude80 PathFinder isn't just a game \u2014 it's an adventure into the world of pathfinding algorithm visualizations . Whether you're a gamer, a curious mind, or an educator, PathFinder brings the complex world of Q-learning and Dijkstra's to life in a way that's engaging, educational, and just plain fun.","title":"Welcome to PathFinders"},{"location":"download/","text":"Download for yourself to try! Download game Windows MacOS Linux Download source code from github > git clone https://github.com/dakotacsk/PIE_ShortestPathFindingVisualization > cd PIE_ShortestPathFindingVisualization","title":"Download!"},{"location":"download/#download-for-yourself-to-try","text":"","title":"Download for yourself to try!"},{"location":"team/","text":"Our team combines expertise in software development, mechanical engineering, and UI/UX design to bring PathFinder to life. Meet the passionate individuals behind the project: Dakota Role : Pathfinding Algorithm Specialist & UI/UX Designer Dakota is focused on understanding pathfinding algorithms, designing user-friendly interfaces, and creating physical demonstrations of abstract concepts. Vishnu Role : Raspberry Pi Integration & Pathfinding Algorithms Vishnu specializes in integrating software with Raspberry Pi, working on approachable UI design, and exploring pathfinding algorithms. Khoi Role : Mechanical-Software Bridge & Real-Time Visuals Khoi bridges the gap between mechanical and software components, creating real-time digital visuals and ensuring seamless integration. Chris Role : Mechanical, Electrical, and Software Design Integration Chris excels at integrating mechanical, electrical, and software designs into cohesive, functional systems inspired by 1980s arcade machines.","title":"Meet the Team"},{"location":"team/#meet-the-passionate-individuals-behind-the-project","text":"","title":"Meet the passionate individuals behind the project:"},{"location":"project/ece_firmware/","text":"ECE SPECIFIC PAGE: ECE & Firmware Design Electrical Design Our electrical system has three main components: the monitor, Raspberry Pi, and the breadboard/buttons/circuits. The monitor and Raspberry Pi are both powered separately. The Raspberry Pi is powered via the USB C port on the RasPi and is connected to one of the USB A ports on our laptops. The monitor is plugged directly into a wall outlet. The breadboard is powered via the 5V pin of the Rasberry Pi, and is also connected to the ground of the Pi. The breadboard consists of multiple buttons with pulldown resistors. When the buttons are pressed, current and voltage passes through the lower powered resistors attached to the button, and that current is read by a GPIO pin on the Raspberry Pi. The Raspberry Pi is connected to the monitor via its micro HDMI port, connecting to one of the two HDMI ports on the monitor. Firmware Design For each button, a GPIO pin on the Raspberry Pi reads high if it is pressed, and low if it is not pressed. We have a file in our code with a ButtonSensing class, with two key functions. checkButtonPress(pin), can take inputs 0-6, corresponding to the 7 buttons in the assembly. This function returns True if the button was previously not pressed down but is now currently being pressed. The checkButtonHold(pin) function returns true if the button corresponding to pin is actively being held down. Example Snippet : import RPi.GPIO as GPIO import time # Set up the GPIO mode to BCM (Broadcom pin numbering) GPIO.setmode(GPIO.BCM) # List of GPIO pins to which the buttons are connected button_pins = [17, 27, 22, 5, 6, 13, 23] # Set up each GPIO pin as an input with pull-up resistor enabled for pin in button_pins: GPIO.setup(pin, GPIO.IN, pull_up_down=GPIO.PUD_UP) try: while True: for pin in button_pins: button_state = GPIO.input(pin) if button_state == GPIO.HIGH: print(f\"Button on GPIO {pin} is pressed!\") else: print(f\"Button on GPIO {pin} is not pressed.\") time.sleep(0.5) # Check every 0.5 seconds except KeyboardInterrupt: print(\"Program terminated\") finally: GPIO.cleanup() # Clean up the GPIO settings when the program exits Link to Source Code : Firmware Repo Link Process Design Decisions We began the electrical design with 6 buttons and an arduino, which we eventually shifted to 7 buttons and a Raspberry Pi. This was because the Raspberry Pi was stronger and able to store and run our game code. The additional button was simply added for game/mechanical integration. Challenges One challenge we faced was keeping the Raspberry Pi at a level temperature and to not overheat it. To work with this, we decreased the load on the Raspberry Pi by running fewer applications at the same time as well as by adding a temperature check that we monitored. Another challenge we faced was with the resistors we were using. The Raspberry Pi has a maximum current draw of 300 mA, meaning that our pulldown resistors needed to be at least 15 ohms. This ended up being less of a challenge, and more of a thing we didn\u2019t think to consider until after working on this project. Progress Timeline For the first sprint, the first steps were in creating a controller. Using the buttons we had purchased, a breadboard, and an arduino. Starting with only 6 buttons we soldered each, connecting them all to the bread board and attached the arduino. We were able to recognize button presses from the arduino after this sprint. By the second sprint we had switched the arduino for a Raspberry Pi. This step was followed by the addition of a seventh button. The Raspberry Pi was then able to connect to the monitor through an HDMI cable and run/display the pre downloaded code. By the third sprint, we were able to make the game playable entirely by the buttons, in previous sprints we had to use a keyboard and mouse to play the game. We also optimized the screen size so that the game fills our monitor screen entirely, making the game feel immersive.","title":"Firmware & ECE Process"},{"location":"project/ece_firmware/#ece-firmware-design","text":"","title":"ECE &amp; Firmware Design"},{"location":"project/meche/","text":"Mechanical Design Process Table of Contents Sprint 1 Sprint 2 Sprint 3 Sprint 1 In this sprint, we focused on laying the groundwork for the arcade machine by building prototypes and refining measurements. Goals: Create a functional button box to test ergonomics. Measure and confirm dimensions for key components: Screen placement. Button spacing and height. Test initial assembly techniques, such as using notches and wood glue for connections. Challenges: Initial measurements needed adjustments to fit the 24\u201dx18\u201d MDF sheets and the monitor size. Ergonomic testing led to refinements in button spacing and control panel height. Sprint 2 During Sprint 2, we transitioned from prototyping to designing the system in CAD and finalizing its structure. Goals: Create detailed CAD models of all components. Incorporate features like: A slanted screen holder for better ergonomics. A modular control panel for easier troubleshooting and maintenance. Key Updates: CAD models ensured precise alignment and fit for all parts. Laser cutter constraints were factored into the design, minimizing material waste. Challenges: Balancing design complexity with fabrication constraints required iterative adjustments. Ensuring all components fit within the laser cutter's dimensions added design constraints. Sprint 3 This sprint focused on fabrication, assembly, and resolving challenges encountered during the build process. Goals: Cut parts from MDF using laser cutters . Paint inner and outer panels using gouache and spray paint, respectively. Assemble the system with wood glue and sanded joints for durability. Final Updates: Successfully assembled the arcade system with modular features for maintenance and upgrades. Painted surfaces added durability and aesthetics. Challenges: Wood glue issue: It didn\u2019t adhere well to painted surfaces, requiring joint areas to be sanded for a proper bond. Assembly required precision to fit parts seamlessly after adjustments. Design Decisions The arcade controller is a problem of ergonomics. We chose to keep the right and left hand relatively close to each other so that it would be possible to use one hand. However, they are angled so that the arms would naturally bend to press the buttons. Additionally, since we expected the user to play standing up, we raised the controls to be about 3 inches over the table, with a 6\u00b0 incline towards the screen. Button distance and angles were determined based off of team member hands. Most arcade machines use a joystick, but a joystick does not make sense for the context of our game. Thus, we incorporated a D-pad design. For the arcade cabinet, we were constrained by the monitor size (24 inch screen with considerable margins) and the maximum size sheet that the laser cutter can cut (24\u201dx18\u201d). Another consideration that arises was the screen height. We expect that this tabletop arcade will be played standing up. Thus, the controller and screen should be put at a certain height. Additionally, the screen should be tilted so that it is directly facing a standing up user. Challenges Access to the monitor\u2019s power button presented an interesting challenge. Unlike traditional monitors with rear or bottom facing buttons, our monitor used a tactile sensor located in the front. To overcome this challenge, we had to cut into the screen holder, which led into structural complications as it created a concentration of stress. Progress Timeline First Sprint First controller created Button integration Second Sprint Second controller designed Integration plan with arcade panel First arcade CAD created Third Sprint Finalized arcade CAD Laser cut and mount components Painting and aesthetic elements Next Steps With the mechanical assembly complete, the system is ready for integration with electrical and software components. The focus will shift toward refining usability and ensuring durability in real-world operation. For more details, refer to the Project Overview .","title":"Mechanical Process"},{"location":"project/meche/#mechanical-design-process","text":"","title":"Mechanical Design Process"},{"location":"project/project/","text":"Project Overview Table of Contents Budget and Components Media Mechanical Design Electrical and Firmware Design Software Design Energy Flow & System Diagrams Budget and Components Spending Breakdown Component/Material Cost (USD) Source Computer Monitor Free (Estimated: $50) PIE Studio Micro HDMI to HDMI Cord $8.79 Amazon Raspberry Pi 4 Model B $56 Amazon Medium Density Fiberboard Free (Estimated: $15) Olin Shop Black Gouache Paint Free (Estimated: $3) Library Workroom Buttons $11.49 Amazon Spray Paint Free (Estimated: $5) Weissman Foundry Breadboard, Resistors, Wires Free (Estimated: $3) PIE Room Total Estimated Cost : $152.28 (including estimated values). Total Cost and Budget Overview Our budget totals to be around 150 dollars, which is well under the 250 dollar budget given to us by the PIE teaching team. Looking back on our project, while we could have bought nicer supplies like a newer RasPi or Monitor, or more expensive paint/wood, there was no need. Our machine functions for its intended purpose, and the cheap materials we had on hand helped us achieve our end goal. Media Final System in Action Mechanical Design The mechanical design of the arcade machine emphasizes durability, modularity, and ergonomic user interaction. Overview: The final structure was laser-cut from 24\u201dx18\u201d \u00bc\u201d MDF sheets, with gouache-painted inner panels and spray-painted outer surfaces. The modular control panel allows for easy troubleshooting, while access to the back enables maintenance. A slanted screen holder optimizes viewing angles and screen height for user comfort. Key Features: Materials: MDF sheets, gouache, and spray paint. Fabrication Methods: Laser cutting and wood glue assembly with sanded joints for improved adhesion. Modularity: Removable control panel and accessible screen holder for power button operation. CAD Rendering Replace this with a CAD rendering or diagram showcasing the design: Figure: CAD rendering of the arcade machine structure. Electrical and Firmware Design Our electrical system has three main components: the monitor, Raspberry Pi, and the breadboard/buttons/circuits. The monitor and Raspberry Pi are both powered separately. The Raspberry Pi is powered via the USB C port on the RasPi and is connected to one of the USB A ports on our laptops. The monitor is plugged directly into a wall outlet. The breadboard is powered via the 5V pin of the Rasberry Pi, and is also connected to the ground of the Pi. The breadboard consists of multiple buttons with pulldown resistors. When the buttons are pressed, current and voltage passes through the lower powered resistors attached to the button, and that current is read by a GPIO pin on the Raspberry Pi. The Raspberry Pi is connected to the monitor via its micro HDMI port, connecting to one of the two HDMI ports on the monitor. Example : Figure: Circuit schematic showing connections between components. Figure: Circuit interfacing with the Raspberry Pi and monitor in the back of the machine. Software Design The software for Hatchling's Quest: Pathfinding Trials is designed to deliver an intuitive, engaging, and educational gaming experience while visualizing pathfinding algorithms in action. Overview: The software is divided into three main areas: Game Interface : Handles the GUI, animations, and user input using Pygame . Pathfinding Algorithms : Dijkstra's Algorithm (Level 1): Computes shortest paths. Q-Learning (Level 2): Enables reward-based navigation. Game Logic : Manages screens, game states, and leaderboards. Key Modules: run_game.py : Coordinates game flow. grid/grid.py : Defines the pathfinding grid. Pathfinding Modules : sprites/DijkstraSprite.py : Implements Dijkstra\u2019s Algorithm. sprites/QLearningSprite.py : Implements Q-Learning. Screens : Main menu, instructions, and interactive gameplay feedback. Leaderboard : Tracks and displays high scores via leaderboard/leaderboard.py . Dependencies The software relies on the following external libraries: Python 3.11.7 : Core language used for development. NumPy (2.2.0) : Used for matrix operations in Q-Learning, including Q-table computations. Pygame (2.6.1) : Provides the framework for rendering the game interface and managing user input. Flow Diagram for Game The following flow diagram illustrates the architecture and flow of the game, showing transitions between levels, screens, and algorithms: Figure: Flow diagram representing game architecture and flow. UML Diagram The UML diagram below showcases the architecture and relationships within the game. It highlights key components, such as the flow between screens, sprite classes, and grid interactions, as well as how algorithms like Dijkstra's and Q-Learning are integrated: Figure: UML diagram representing the game architecture and component relationships. Link to Source Code The complete source code for the project is hosted on GitHub: GitHub Repo Link More details to be found in subpage named Software Process. Diagrams Data and Energy Flow Diagram Insert a high-level diagram showing how energy and data move through the system. PLACEHOLDER : Add data and energy flow diagram. Example : Figure: Data and energy flow in the arcade system. Subsystem Diagram Example : Figure: Subsystem relationships across hardware, software, and firmware.","title":"Final Overview"},{"location":"project/project/#project-overview","text":"","title":"Project Overview"},{"location":"project/software/","text":"Table of Contents Sprint 1 Sprint 2 Narrative Ideations Sprint 3 Process Sprint 1 Our goal was to build a proof of concept with: A functional grid system . A Dijkstra agent that: Prioritizes green reward blocks . Avoids red punishment blocks . Testing Pygame as the main library. Early progress on the Q-Learning agent . Teaching users the difference between Dijkstra\u2019s Algorithm and Q-Learning . Challenges and Design Decisions 1. External Libraries vs. Customizability Why : Existing libraries (e.g., Gym) ran in their own environments and were hard to customize. Decision : Full control over sprites and mechanics for flexibility. Pivot : Develop modular tools to speed up development without losing control. 2. Teaching Dijkstra vs. Q-Learning Challenge : The two algorithms are too different for straightforward comparison. Struggle : Aligning gameplay and storyline to highlight their unique applications. Pivot : Refocus the storyline to show how each algorithm solves unique problems instead of directly comparing them. 3. Mechanics Development Issue : Without external libraries, we\u2019re spending significant time on foundational mechanics. Pivot : Use lightweight tools (e.g., GUI libraries) to improve efficiency without losing control. 4. Playtesting Barriers Problem : The game feels too technical for players without RL knowledge . Pivot : Add visual aids (e.g., overlays, step-by-step explanations) to teach key mechanics. Simplify early levels for intuitive gameplay. 5. Grid Size and Performance Challenge : Larger grids stress GPU/CPU resources and increase training time. Why not pre-train? : Real-time, dynamic training is a key feature. Pivot : Start with smaller grids and scale gradually. Optimize Q-Learning to reduce computational overhead. 6. Storyline Integration Issue : Tying gameplay, RL mechanics, and a compelling storyline is difficult. Pivot : Simplify the narrative to focus on goal-driven challenges where each algorithm\u2019s strengths shine. Sprint 2 For Sprint 2, we focused on graphics, gameplay tweaks , and building an MVP styled as an old arcade game . 1. Q-Learning Enhancements Fully functional Q-Learning sprite . Real-time Q-Table Visualization for intuitive learning feedback. 2. User Interface Functional Home Page and two Instruction Screens : Simple gameplay explanation. Overview of Dijkstra\u2019s Algorithm and Q-Learning . Added a Credits Screen with consistent styling. 3. Gameplay Feedback On-screen messages show: Current step of the Q-Learning sprite. Progress out of 5000 max steps . 4. Visual Updates Adjusted to a horizontal layout for arcade monitor compatibility. Limited controls to 6 buttons for simplicity. 5. Scrolling Text Standardized scrolling text animations with a base class . 6. Leaderboard Screen Added a non-functional leaderboard screen (debugging in progress). 7. Explanation Screen Added screens to explain sprite oscillation and invalid moves during Q-Learning. Challenges and Potential Pivots 1. Storyline Development Issue : We still struggle to develop a cohesive storyline. Pivot : Use the Dijkstra sprite as a tutorial to introduce mechanics. Simplify the narrative into progression-based challenges . 2. Q-Table Display Issue : Q-Table numbers overlap, creating clutter. Fix : Tweak reward/punishment values. Round displayed Q-table numbers for clarity. 3. Leaderboard Issues Issue : Leaderboard functionality is incomplete. Fix : Debug and finalize leaderboard tracking for high scores. 4. Max Steps Taking Too Long Issue : 5000 steps feel excessive and slow down gameplay. Pivot : Allow users to adjust step sizes (e.g., 100, 500, 1000). Streamline gameplay to reduce unnecessary steps. 5. Gameplay Consistency Issue : The game doesn\u2019t always behave as expected. Fix : Perform a parameter sweep to balance rewards, punishments, and grid size. Ensure consistent gameplay that\u2019s challenging but winnable . Narrative Ideations In Sprint 2, we explored potential storylines to align gameplay with engaging narratives. 1. Car Game Concept : A car loses gas with each step. Red squares : Obstacles increasing gas loss. Green squares : Gas stations for refueling. Fix : Dijkstra : Efficient route to gas stations. Q-Learning : Adaptive navigation to avoid obstacles. 2. Park Game Concept : Park-goers navigate delays and rewards. Red squares : Monuments or benches. Green squares : Fields requiring maintenance. Fix : Dijkstra : Optimized static pathfinding. Q-Learning : Adapts dynamically to new obstacles. 3. Immigrant Boat Game Concept : Escape threats while maintaining morale. Green squares : Safe havens. Red squares : Pirates reducing morale. Fix : Dijkstra : Safest, most optimal path. Q-Learning : Learns dynamically to avoid threats. Next Steps Select and integrate a streamlined narrative . Align rewards and punishments with storyline progression. Optimize mechanics to balance user engagement and educational value . Here\u2019s Sprint 3 formatted cleanly and consistently with your earlier sections: Sprint 3 Narrative Ideation We settled on a storyline where baby turtles must find their way to the ocean after hatching. The game aims to: Educate users on reinforcement learning algorithms . Teach users about the natural behavior of turtle hatchlings. Spread awareness on the issue of light pollution and its impact on nature. Final Updates Sprite images added! Storyline integrated into the gameplay. Bugs fixed to improve robustness. Option to choose max steps added for better gameplay flexibility. File reorganization completed to prepare for a downloadable app . Challenges and Pivots At this stage, the primary focus is on: Pivot : Finishing the final touches and fixing all remaining bugs to ensure the game is robust and ready for release. You can see the final results in the Project Overview ! Alternatively, feel free to play the game using the download page.","title":"Software Process"},{"location":"project/software/#process","text":"","title":"Process"}]}